引入 用户界面;
公开 类 启动类
{
	公开 静态 启动()
	{
		窗口应用程序 窗口1 = 创建 窗口应用程序;
		窗口1.启动();
	}
}

公开 类 窗口应用程序<基类型 = 界面程序>
{
	 t t1;
	公开 逻辑 初始化程序()
	{
		t1 = 创建 t;
		t1.创建窗口();
		返回 真;
	}
}

公开 类 词法分析类
{
	公开 文本 被分析的文本;
	公开 文本[] 单词数组;
	公开 整数[] 类型数组;
	公开 整数 当前位置;
	公开 整数 单词总数;
	公开 初始化()
	{
		单词数组=创建 文本[100];
		类型数组=创建 整数[100];
		当前位置=0;
		单词总数=0;
	}
	公开 初始化(文本 要分析的文本)
	{
		被分析的文本= 要分析的文本;
		初始化();
	}
	公开 属性 整数 当前字符类型()
	{
		整数 c=文本类.取字符( 被分析的文本.中间(当前位置,1));
		如果(65<=c<=90 || 97<=c<=122)
			返回(字符类型.字母 );
		如果(48<=c<=57)
			返回(字符类型.数字 );
		如果(33<=c<=47 || 91<=c<=96 || 58<=c<=64 || 123<=c<=127)
			返回(字符类型.符号 );
		如果(0<=c<=32)
			返回(字符类型.不可见字符);
		否则
			返回(字符类型.其他);
	}
	公开 读一个数值()
	{
		整数 字母E出现的次数=0,字母E出现的位置,正负号出现的次数=0,小数点出现的次数=0,开始的位置=当前位置;
		文本 当前字符;
		循环(当前位置<被分析的文本.长度)
		{
			当前字符=被分析的文本.中间(当前位置,1);
			假如(当前字符类型)
			{
			为 字符类型.数字:
				当前位置++;
			为 字符类型.字母:
				如果((当前字符=="E" || 当前字符=="e") && 字母E出现的次数<1 && 开始的位置<当前位置 )
				{
					字母E出现的位置= 当前位置;
					字母E出现的次数++;
					当前位置++;
				}
				否则{
					添加单词(单词类型.数值,开始的位置,当前位置-1);
					返回;
				}
				为 字符类型.符号:
					如果((当前字符=="+" || 当前字符=="-") && (开始的位置==当前位置 || 字母E出现的位置==当前位置-1) && 正负号出现的次数<2)
					{
						正负号出现的次数++;
						当前位置++;
					}
					又如(当前字符=="." && 小数点出现的次数<1)
					{
						小数点出现的次数++;
						当前位置++;
					}否则{
						添加单词(单词类型.数值,开始的位置,当前位置-1);
						返回;
					}
					为其他:
						添加单词(单词类型.数值,开始的位置,当前位置-1);
						返回;
			}
		}
		添加单词(单词类型.数值,开始的位置,当前位置);
	}
	公开 读一个标识符()
	{
		整数 开始的位置=当前位置;
		文本 当前字符;
		循环(当前位置<被分析的文本.长度)
		{
			当前字符=被分析的文本.中间(当前位置,1);
			假如(当前字符类型)
			{
			为 字符类型.字母:
				当前位置++;
			为 字符类型.其他:
				当前位置++;
			为 字符类型.数字:
				如果(开始的位置<当前位置 )
					当前位置++;
				否则{
					添加单词(单词类型.标识符,开始的位置,当前位置-1);
					返回;
				}
				为 字符类型.符号:
					如果(当前字符=="_" )
						当前位置++;
					否则{
						添加单词(单词类型.标识符,开始的位置,当前位置-1);
						返回;
					}
					为其他:
						添加单词(单词类型.标识符,开始的位置,当前位置-1);
						返回;
			}
		}
		添加单词(单词类型.标识符,开始的位置,当前位置);
	}
	公开 读一个运算符()
	{
		整数 开始的位置=当前位置;
		文本 当前字符;
		循环(当前位置<被分析的文本.长度)
		{
			当前字符=被分析的文本.中间(当前位置,1);
			如果(当前字符类型==字符类型.符号)
			{
				如果(当前字符==整数类.字符到文本(34))
				{
					如果(开始的位置==当前位置)
					{
						读一个字符串();
						返回;
					}否则{
						添加单词(单词类型.运算符,开始的位置,当前位置-1);
						读一个字符串();
						返回;
					}
				}
				又如(当前字符=="(" || 当前字符==")" || 当前字符=="[" || 当前字符=="]")
				{
					如果(开始的位置<当前位置)
					{
						添加单词(单词类型.运算符,开始的位置,当前位置-1);
					}
					添加单词(单词类型.运算符,当前位置,当前位置);
					当前位置++;
					返回;
				}	
				又如(当前字符=="_" && 开始的位置==当前位置)
				{
					读一个标识符();
					返回;
				}否则{
					当前位置++;
				}
			}
			添加单词(单词类型.运算符,开始的位置,当前位置-1);
			返回;
		}
		添加单词(单词类型.运算符,开始的位置,当前位置);
	}
	公开 读一个字符串()
	{
		整数 开始的位置=当前位置,双引号出现的次数=0;
		整数 当前字符;
		循环(当前位置<被分析的文本.长度)
		{
			当前字符=文本类.取字符(被分析的文本.中间(当前位置,1));
			如果(当前字符==34 )
			{
				双引号出现的次数++;
				如果(双引号出现的次数<2)
					当前位置++;
				否则{
					添加单词(单词类型.字符串 ,开始的位置,当前位置);
					当前位置++;
					返回;
				}
			}
			否则{
				当前位置++;
			}
		}
		添加单词(单词类型.字符串,开始的位置,当前位置);
	}
	公开 添加单词(整数 单词的类型, 整数 开始位置,整数 结束位置)
	{
		如果( 单词总数>=单词数组.长度)
		{
			文本[] 临时单词数组=创建 文本[单词数组.长度+100 ];
			单词数组.复制(临时单词数组,0,单词数组.长度 ,0);
			单词数组= 创建 文本[临时单词数组.长度];
			临时单词数组.复制(单词数组,0,单词数组.长度 ,0);
			整数[] 临时类型数组=创建 整数[类型数组.长度+100 ];
			类型数组.复制(临时类型数组,0,类型数组.长度 ,0);
			类型数组= 创建 整数[临时类型数组.长度];
			临时类型数组.复制(类型数组,0,类型数组.长度 ,0);
		}	
		单词数组[单词总数]=被分析的文本.中间( 开始位置,结束位置-开始位置+1);
		类型数组[单词总数]=单词的类型;
		单词总数++;
	}
	公开 分析()
	{
		文本 当前字符;
		循环(当前位置<被分析的文本.长度 )
		{
			当前字符=被分析的文本.中间(当前位置,1);
			假如(当前字符类型)
			{
			为 字符类型.数字:
				读一个数值();
			为 字符类型.字母:
				读一个标识符();
			为 字符类型.其他:
				读一个标识符();
			为 字符类型.符号:
				读一个运算符();
			为其他:
				当前位置++;
			}
		}
	}
}

公开 枚举 单词类型 {数值=1,标识符=2,字符串=3,运算符=4}
公开 枚举 字符类型 {数字=1,字母=2,符号=3,不可见字符=4,其他=0}